# -*- coding: utf-8 -*-
"""
Ã‰diteur de Spyder

Ceci est un script temporaire.
"""

import ctypes
import numpy as np
import imageio
from os.path import expanduser
import visvis as vv
# set the directory for the c .so
home_dir = expanduser("~")
LIBTEST = 'C:\Users\hayari\Documents\python/'

# load the .so (dynamic library) using ctypes
EMX = ctypes.cdll.LoadLibrary(LIBTEST + 'mypyr.so')
init = EMX. makePyramid_2D_initialize()
print '\nInitialize...\n'
data_in = imageio.imread(LIBTEST + 'test.tif')
data_in =data_in.astype(float)

titi=TestEmxAPI(data_in)
tata=np.array(titi.gradX)
#vv.imshow(np.array(titi.gradX))

def TestEmxAPI(data_in):
   # Create a data structure to hold the pointer generated by 
    #  emxCreateWrapper...
    class Opaque(ctypes.Structure):
        pass
    
    L = len(data_in)
    # create an empty array of the same size for the output
    data_ou = [0] * L
    sz=(data_in.shape)
   
#    tutu=(ctypes.c_double*sz[0])*sz[1]
    class DoubleArrayType: 
        def from_param(self, param): 
          
            typename = type(param).__name__ 
          
            if hasattr(self, 'from_' + typename): 
                return getattr(self, 'from_' + typename)(param) 
          
            elif isinstance(param, ctypes.Array): 
                return param 
          
            else: 
                raise TypeError("Can't convert % s" % typename) 
  
    # Cast from array.array objects 
        def from_array(self, param): 
            if param.typecode != 'd': 
                raise TypeError('must be an array of doubles') 
          
            ptr, _ = param.buffer_info() 
            return ctypes.cast(ptr, ctypes.POINTER(ctypes.c_double)) 
          
    # Cast from lists / tuples 
        def from_list(self, param): 
            val = ((ctypes.c_double)*len(param))(*param) 
            return val 
      
        from_tuple = from_list 
      
    # Cast from a numpy array 
        def from_ndarray(self, param): 
            return param.ctypes.data_as(ctypes.POINTER(ctypes.c_double))
            #return param.ctypes.data
    DoubleArray = DoubleArrayType() 
    
    data_in.ctypes.data_as(ctypes.POINTER(ctypes.c_double))
    class Pyr(ctypes.Structure): 
        _fields_ = [('img', (ctypes.c_double*sz[0])*sz[1]), ('gradX', (ctypes.c_double*sz[0])*sz[1]),('gradY', (ctypes.c_double*sz[0])*sz[1])] 
##
#    #oua = (ctypes.c_double * L)(*data_ou)
#    # create a pointer for these arrays & set the rows and columns of the matrix
#    inp = DoubleArrayType
#    #oup = ctypes.pointer(oua)
#    
    nrows = ctypes.c_int(sz[0])
    ncols = ctypes.c_int(sz[1])
    level=1
    blur=-1
    win=np.array([10.,10.,10.])
    winc= (ctypes.c_double *3)(*win)
    # use EMX.emxCreateWrapper_real_T(double *data, int rows, int cols) to generate an emx wrapping the data 
    # input arg types are a pointer to the data NOTE it's not great to have to resize the ctypes.c_double
#    EMX.emxCreateWrapper_real_T.argtypes = (DoubleArray, ctypes.c_int, ctypes.c_int)
###    # a pointer to the emxArray is returned and stored in Opaque
#    EMX.emxCreateWrapper_real_T.restype = ctypes.POINTER(Opaque)
  
    pp=Pyr()
    
    #in_emx = EMX.emxCreateWrapper_real_T(data_in, sz[0], sz[1])
    in_emx = EMX.emxCreateWrapper_real_T(data_in.ctypes.data_as(ctypes.POINTER(ctypes.c_double)), nrows,ncols) 
    EMX.emxCreateWrapper_struct0_T.argtypes=(ctypes.POINTER(Pyr),ctypes.c_int,ctypes.c_int)
    EMX.emxCreateWrapper_struct0_T.restype = ctypes.POINTER(Pyr)
    ou_emx = EMX.emxCreateWrapper_struct0_T(pp,sz[0], sz[1])

   
    EMX.makePyramid_2D(in_emx, ctypes.c_double(level),ctypes.c_double(blur),winc, ou_emx)
#    
#    # clear the heap removing the emx 
#    EMX.emxDestroyArray_real_T(in_emx)
#    EMX.emxDestroyArray_real_T(ou_emx)
 

    return pp
